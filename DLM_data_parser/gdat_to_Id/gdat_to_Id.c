// gdat_to_Id.c
//  This program will take in a gdat file generated by the DLM and
//  convert it to a .Id file that can be read in I2. Data that comes
//  out will not match exactly as gdat stores data with a timestamp
//  attached and does not need to be a consistant frequency, but I2
//  data does need to be

#include "gdat_to_Id.h"
#include <stdlib.h>
#include <string.h>
#include <stdio.h>


// define everything that is neede in static memory
START_OF_FILE_t sof_data = {0};
FILE_METADATA_t file_data = {0};

const U8 edl_ver_string[] = EDL_VERSION_STRING;
const U8 magic_string[] = MAGIC_STRING;


// the head node WILL NOT be written in memory so it do not count it
CHANNEL_DESC_LL_NODE_t channel_head = 
{
    .channel_desc = {0},
    .location_fptr = 0,
    .data_buffer = NULL,
    .prev = NULL,
    .next = NULL,
};


int main(int argc, char** argv)
{
    // read in the gdat file and store all the data in ram with some linked
    // lists for all of the data nodes. Do some fancy math to figure out what
    // the offset, scaler, divisor, and base10_shift should be. Also find the
    // logging frequency
    // TODO

    // take the data from gdat and use it to fill in all of the Id data headers
    // and data buffers. This will not fill in the pointers yet
    // TODO

    // fill in all of the names and metadata for the Id file. This includes the
    // date and time from the gdat file, as well as event name, session, comments,
    // and location
    // TODO

    // DEBUG filling in the sof and metadata
    init_sof_block(&sof_data, 2022, 3, 30, 4, 20, 55, "SESSION", "SHORT COMMENT", "TEAM NAME");
    init_metadata_block(&file_data, "EVENT NAME", "SESSION", "LONG COMMENT", "LOCATION");

    // DEBUG add a couple of data points for testing
    // Doing 100 data points at 10 Hz
    U32 buf[100];
    for (int c = 0; c < 100; c++) buf[c] = c;
    add_channel_to_list(&channel_head, 100, buf, 10, 0, 1, 1, 0, "tester variable", "test", "unit");
    add_channel_to_list(&channel_head, 100, buf, 10, 0, 1, 1, 0, "tester variable 2", "test2", "unit2");

    // Run the "linker". This will fill out correct file space for all of the different
    // blocks of data and makes sure they will be correctly pointed to in the file
    link_id_file(&sof_data, &file_data, &channel_head);

    // Open a new file with the correct name and begin writing all of the data to it.
    // Layout the file as planned after the linker was run
    write_id_file(&sof_data, &file_data, &channel_head, "test_Id.Id");

    printf("Conversion sucessful\n");
}


// add_channel_to_list
//  Add a new channel to the list of channels. Send in all of the information for this
//  node
S8 add_channel_to_list(CHANNEL_DESC_LL_NODE_t* chan_head, U32 num_data_points, U32* buffer, U16 log_fq_Hz,
                       S16 offset, S16 scaler, S16 divisor, S16 b10_shift,
                       const char* name, const char* name_short, const char* unit)
{
    CHANNEL_DESC_LL_NODE_t* new_chan;

    // make a new LL node and put it in the list, updating the prev and next
    // pointers accordingly
    new_chan = (CHANNEL_DESC_LL_NODE_t*)malloc(sizeof(CHANNEL_DESC_LL_NODE_t));
    if (!new_chan)
    {
        printf("failed a malloc\n");
        return -1;
    }
    new_chan->next = chan_head->next;
    new_chan->prev = chan_head;
    chan_head->next = new_chan;
    if (new_chan->next) new_chan->next->prev = new_chan;

    // assign the things that can be just copied
    new_chan->channel_desc.num_data_points = num_data_points;
    new_chan->data_buffer = buffer;
    new_chan->channel_desc.logging_freq_hz = log_fq_Hz;
    new_chan->channel_desc.data_offset = offset;
    new_chan->channel_desc.data_scaler = scaler;
    new_chan->channel_desc.data_divisor = divisor;
    new_chan->channel_desc.data_base10_shift = b10_shift;

    // always do 32bit for now
    new_chan->channel_desc.data_size = s32_data;

    // for the strings, assign up to the null char or the maximum length of
    // the string, whichever comed first (strncpy)
    strncpy(new_chan->channel_desc.channel_name_str, name, sizeof(new_chan->channel_desc.channel_name_str));
    strncpy(new_chan->channel_desc.chan_name_short_str, name_short, sizeof(new_chan->channel_desc.chan_name_short_str));
    strncpy(new_chan->channel_desc.channel_unit_str, unit, sizeof(new_chan->channel_desc.channel_unit_str));

    return 0;
}


S8 init_sof_block(START_OF_FILE_t* sof, U16 year, U8 month, U8 day, U8 hour, U8 minute, U8 second,
                  const char* session, const char* short_comment, const char* team_name)
{
    char date_str[sizeof(sof->date) + 1];
    char time_str[sizeof(sof->time) + 1];

    // fill in the things that dont change
    sof->version_string_fptr = EDL_VER_STR_FLOC;
    sof->dash_version_string_fptr = 0x0;
    memcpy(sof->edl_version_string, edl_ver_string, sizeof(sof->edl_version_string));
    memcpy(sof->magic_str, magic_string, sizeof(sof->magic_str));

    // fill in the time and data with sprintfs. Make sure to keep the lengths correct
    sprintf(time_str, "%02d:%02d:%02d", hour, minute, second);
    sprintf(date_str, "%02d/%02d/%04d", day, month, year);
    strncpy(sof->time, time_str, sizeof(sof->time));
    strncpy(sof->date, date_str, sizeof(sof->date));

    // fill in the strings
    strncpy(sof->session_str, session, sizeof(sof->session_str));
    strncpy(sof->short_comment_str, short_comment, sizeof(sof->short_comment_str));
    strncpy(sof->team_name_str, team_name, sizeof(sof->team_name_str));

    return 0;
}


S8 init_metadata_block(FILE_METADATA_t* metadat, const char* event_name, const char* session,
                       const char* long_comment, const char* location)
{
    strncpy(metadat->event_name_str, event_name, sizeof(metadat->event_name_str));
    strncpy(metadat->session_str, session, sizeof(metadat->session_str));
    strncpy(metadat->long_comment_str, long_comment, sizeof(metadat->long_comment_str));
    strncpy(metadat->location_str, location, sizeof(metadat->location_str));
}


// link_id_file
//  Decide the locations of all of the different parts of the file and fill in the correct
//  fptrs. There will be lots of #defines for starts of blocks for things that can be anywhere 
S8 link_id_file(START_OF_FILE_t* sof, FILE_METADATA_t* metadat, CHANNEL_DESC_LL_NODE_t* chan_head)
{
    U32 num_channels = 0;
    U32 curr_file_loc = 0;
    CHANNEL_DESC_LL_NODE_t* chan_ptr = chan_head->next;

    // put the arbitrary things where they are #defined to be
    sof->version_string_fptr = EDL_VER_STR_FLOC;
    sof->dash_version_string_fptr = 0x00; // this does not seem to be needed
    sof->channel_ll_first_fptr = CHANNEL_DESC_START_FLOC; // there needs to be at least one channel
    sof->file_metadata_block_fptr = FILE_METADATA_FLOC;

    // the first data point will be directly after the channels
    while (chan_ptr != NULL)
    {
        num_channels++;
        chan_ptr = chan_ptr->next;
    }
    sof->data_start_fptr = CHANNEL_DESC_START_FLOC + (num_channels * CHANNEL_DESC_SIZE);

    // set the location pointer for the location string. It will be direcly after the file metadata
    // struct
    metadat->location_fptr = FILE_METADATA_FLOC + FILE_METADATA_SIZE - sizeof(metadat->location_str);

    // for each of the channels, fill in the pointers to previous and next
    chan_ptr = chan_head->next;
    curr_file_loc = CHANNEL_DESC_START_FLOC;
    while (chan_ptr != NULL)
    {
        // set this nodes location and 
        chan_ptr->location_fptr = curr_file_loc;
        curr_file_loc += CHANNEL_DESC_SIZE;

        if (chan_ptr->prev == chan_head)
        {
            chan_ptr->channel_desc.prev_fptr = 0;
        }
        else
        {
            // if the node before is not the head, set the location of this node to it and
            // set the location of the previous node to this onme
            chan_ptr->channel_desc.prev_fptr = chan_ptr->prev->location_fptr;
            chan_ptr->prev->channel_desc.next_fptr = chan_ptr->location_fptr;
        }

        // set the file location of the next node to 0, it will get fixed if the next node
        // is not null next run through the loop
        chan_ptr->channel_desc.next_fptr = 0;

        chan_ptr = chan_ptr->next;
    }

    // at the end of the channels, start putting the data buffers and add the location to the
    // channel. The curr_file_loc is now at the start of the data
    chan_ptr = chan_head->next;
    while (chan_ptr != NULL)
    {
        chan_ptr->channel_desc.data_buf_fptr = curr_file_loc;

        // move the curr_file_loc to be right after this block of data
        if (chan_ptr->channel_desc.data_size == s16_data)
        {
            // 16bit data points
            curr_file_loc += (chan_ptr->channel_desc.num_data_points * sizeof(U16));
        }
        else
        {
            // 32bit data points
            curr_file_loc += (chan_ptr->channel_desc.num_data_points * sizeof(U32));
        }

        chan_ptr = chan_ptr->next;
    }
}


// write_id_file
//  take the parts of the files and write them. Be sure to look at the fptrs in the data
//  to put everything where it belongs in the file. All values must be little endian
S8 write_id_file(START_OF_FILE_t* sof, FILE_METADATA_t* metadat, CHANNEL_DESC_LL_NODE_t* chan_head,
                 const char* filename)
{
    FILE* file;
    CHANNEL_DESC_LL_NODE_t* chan_ptr;
    U8 sof_str[START_OF_FILE_SIZE] = {0};
    U8 metadat_str[FILE_METADATA_SIZE] = {0};
    U8 chan_desc_str[CHANNEL_DESC_SIZE] = {0};

    // make the new file
    file = fopen(filename, "w");
    if (!file)
    {
        printf("failed to open file\n");
        return -1;
    }

    // if needed, convert all of the data to little endian
    // Linux with AMD: Already big endian
    // WSL and intel: TODO

    // fill in the byte strings for the sof and metadata
    // TODO

    // write the SOF block, this will be at the start of the file
    fseek(file, 0, SEEK_SET);
    fwrite(sof_str, sizeof(sof_str), 1, file);

    // move to the location of the file metadata and write it
    fseek(file, FILE_METADATA_FLOC, SEEK_SET);
    fwrite(metadat_str, sizeof(metadat_str), 1, file);

    // for each channel, write it. Start in the correct location
    fseek(file, CHANNEL_DESC_START_FLOC, SEEK_SET);
    chan_ptr = chan_head->next;

    while(chan_ptr != NULL)
    {
        // convert to a byte string and write
        // TODO

        fwrite(chan_desc_str, sizeof(chan_desc_str), 1, file);
        chan_ptr = chan_ptr->next;
    }

    // for each channel, write the data buffer. This is just continuous memory
    chan_ptr = chan_head->next;
    while(chan_ptr != NULL)
    {
        if (chan_ptr->channel_desc.data_size == s16_data)
        {
            // 16bit data points
            fwrite(chan_ptr->data_buffer, chan_ptr->channel_desc.num_data_points * sizeof(U16),
                   1, file);
        }
        else
        {
            // 32bit data points
            fwrite(chan_ptr->data_buffer, chan_ptr->channel_desc.num_data_points * sizeof(U32),
                   1, file);
        }
        chan_ptr = chan_ptr->next;
    }
}


// sof_to_bytes
//  convert the SOF struct into a raw byte string for writing
void sof_to_bytes(START_OF_FILE_t* sof, U8* bytes)
{
    // TODO
}


// metadata_to_bytes
//  convert the metadata struct into a raw byte string for writing
void metadata_to_bytes(FILE_METADATA_t* metadat, U8* bytes)
{
    // TODO
}


// channel_desc_to_bytes
//  convert the channel description into a raw byte string for writing
void channel_desc_to_bytes(CHANNEL_DESC_t* chan_desc, U8* bytes)
{
    // TODO
}